<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <title>AR Teleport Object Follow Camera</title>

    <!-- Model Viewer -->
    <script
      type="module"
      src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      model-viewer {
        width: 100vw;
        height: 100vh;
      }
      .ar-button {
        background: #007bff;
        color: white;
        border: none;
        padding: 14px 22px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 10;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      }
      .ar-button:active {
        background: #0056cc;
      }
    </style>
  </head>

  <body>
    <model-viewer
      id="mv"
      src="1M.glb"
      ios-src="1M.usdz"
      ar
      ar-modes="webxr scene-viewer quick-look"
      ar-scale="fixed"
      ar-placement="floor"
      camera-controls
      shadow-intensity="1"
      autoplay
      alt="Teleport Model"
      tone-mapping="neutral"
      exposure="1"
      xr-environment
    >
      <button slot="ar-button" class="ar-button">Xem AR</button>
    </model-viewer>

    <script>
      const mv = document.getElementById("mv");
      let followCamera = false;
      let frameHandle = null;
      let lastCameraPos = null;

      mv.addEventListener("ar-status", (event) => {
        if (event.detail.status === "session-started") {
          console.log("ðŸ”¹ AR start - follow camera + teleport");
          followCamera = true;
          startFollowCamera();
        } else if (event.detail.status === "not-presenting") {
          console.log("ðŸ”¹ AR end");
          followCamera = false;
          cancelAnimationFrame(frameHandle);
        }
      });

      function startFollowCamera() {
        const THREE = mv?.THREE || window.MVThree || self.MVThree;

        if (!THREE || !mv.scene || !mv.model) {
          console.warn("â³ ChÆ°a sáºµn sÃ ng THREE hoáº·c model");
          frameHandle = requestAnimationFrame(startFollowCamera);
          return;
        }

        const scene = mv.scene;
        const model = mv.model;
        const camera = scene.camera;
        const distance = 1.0; // khoáº£ng cÃ¡ch model trÆ°á»›c camera
        const teleportThreshold = 0.4; // teleport náº¿u camera di chuyá»ƒn >0.4m

        function update() {
          if (followCamera && camera && model) {
            const currentPos = camera.position.clone();

            if (!lastCameraPos) {
              teleportModel();
              lastCameraPos = currentPos.clone();
            }

            const moveDistance = currentPos.distanceTo(lastCameraPos);
            if (moveDistance > teleportThreshold) {
              console.log(`âš¡ Teleport model (${moveDistance.toFixed(2)}m)`);
              teleportModel();
              lastCameraPos.copy(currentPos);
            }
          }
          frameHandle = requestAnimationFrame(update);
        }

        // Teleport model Ä‘áº¿n trÆ°á»›c camera
        function teleportModel() {
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const targetPos = new THREE.Vector3()
            .copy(camera.position)
            .add(forward.multiplyScalar(distance));

          model.position.copy(targetPos);
          model.quaternion.copy(camera.quaternion);
        }

        update();
      }
    </script>
  </body>
</html>
